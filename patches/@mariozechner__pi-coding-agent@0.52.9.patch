diff --git a/dist/core/agent-session.js b/dist/core/agent-session.js
index 1793edc93311748f2827025eec9aa2ecd1c9f077..09b3441d70e5397747a9d7328abb65da1aa4c889 100644
--- a/dist/core/agent-session.js
+++ b/dist/core/agent-session.js
@@ -1185,15 +1185,17 @@ export class AgentSession {
         // to a larger-context model (e.g. codex) - the overflow error from the old model
         // shouldn't trigger compaction for the new model.
         const sameModel = this.model && assistantMessage.provider === this.model.provider && assistantMessage.model === this.model.id;
-        // Skip overflow check if the error is from before a compaction in the current path.
-        // This handles the case where an error was kept after compaction (in the "kept" region).
-        // The error shouldn't trigger another compaction since we already compacted.
-        // Example: opus fails → switch to codex → compact → switch back to opus → opus error
-        // is still in context but shouldn't trigger compaction again.
+        // Skip if the message is from before a compaction in the current path.
+        // This handles two cases:
+        // 1. Overflow: error kept after compaction (in the "kept" region) shouldn't re-trigger.
+        //    Example: opus fails → switch to codex → compact → switch back to opus → opus error
+        //    is still in context but shouldn't trigger compaction again.
+        // 2. Threshold: pre-prompt check re-evaluates a message already handled at agent_end.
+        //    The stale usage data would incorrectly trigger a second compaction.
         const compactionEntry = this.sessionManager.getBranch().find((e) => e.type === "compaction");
-        const errorIsFromBeforeCompaction = compactionEntry && assistantMessage.timestamp < new Date(compactionEntry.timestamp).getTime();
+        const messageIsFromBeforeCompaction = compactionEntry && assistantMessage.timestamp < new Date(compactionEntry.timestamp).getTime();
         // Case 1: Overflow - LLM returned context overflow error
-        if (sameModel && !errorIsFromBeforeCompaction && isContextOverflow(assistantMessage, contextWindow)) {
+        if (sameModel && !messageIsFromBeforeCompaction && isContextOverflow(assistantMessage, contextWindow)) {
             // Remove the error message from agent state (it IS saved to session for history,
             // but we don't want it in context for the retry)
             const messages = this.agent.state.messages;
@@ -1207,6 +1209,11 @@ export class AgentSession {
         // Skip if this was an error (non-overflow errors don't have usage data)
         if (assistantMessage.stopReason === "error")
             return;
+        // Skip threshold check if the message is from before a compaction.
+        // This prevents double compaction when the pre-prompt check re-evaluates
+        // a message that was already handled at agent_end (stale usage data).
+        if (messageIsFromBeforeCompaction)
+            return;
         const contextTokens = calculateContextTokens(assistantMessage.usage);
         if (shouldCompact(contextTokens, contextWindow, settings)) {
             await this._runAutoCompaction("threshold", false);
